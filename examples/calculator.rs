use std::{fmt::Write, thread, time::Duration};

use backend_embedded_graphics::{
    widgets::{
        label::{LabelConstructor, LabelStyle, LabelStyling},
        primitives::{background::BackgroundStyle, border::BorderStyle},
    },
    EgCanvas,
};
use embedded_graphics::{
    draw_target::DrawTarget,
    mono_font::{ascii::Font6x10, MonoFont, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::Size as EgSize,
};
use embedded_graphics_simulator::{
    sdl2::MouseButton, BinaryColorTheme, OutputSettingsBuilder, SimulatorDisplay, SimulatorEvent,
    Window as SimWindow,
};
use embedded_gui::{
    data::BoundData,
    input::event::{InputEvent, PointerEvent},
    widgets::{
        button::Button,
        label::Label,
        layouts::linear::{column::Column, row::Row, Cell},
        primitives::{
            background::Background,
            border::Border,
            fill::{Center, FillParent, HorizontalAndVertical, Right},
            spacing::Spacing,
        },
        DataHolder, Widget, WidgetWrapper,
    },
    Position, WidgetState, Window,
};
use heapless::{consts::U11, String};

fn convert_input(event: SimulatorEvent) -> Result<InputEvent, bool> {
    unsafe {
        // This is fine for a demo
        static mut MOUSE_DOWN: bool = false;
        match event {
            SimulatorEvent::MouseButtonUp {
                mouse_btn: MouseButton::Left,
                point,
            } => {
                MOUSE_DOWN = false;
                Ok(InputEvent::PointerEvent(
                    Position {
                        x: point.x,
                        y: point.y,
                    },
                    PointerEvent::Up,
                ))
            }
            SimulatorEvent::MouseButtonDown {
                mouse_btn: MouseButton::Left,
                point,
            } => {
                MOUSE_DOWN = true;
                Ok(InputEvent::PointerEvent(
                    Position {
                        x: point.x,
                        y: point.y,
                    },
                    PointerEvent::Down,
                ))
            }
            SimulatorEvent::MouseMove { point } => Ok(InputEvent::PointerEvent(
                Position {
                    x: point.x,
                    y: point.y,
                },
                if MOUSE_DOWN {
                    PointerEvent::Drag
                } else {
                    PointerEvent::Hover
                },
            )),
            SimulatorEvent::Quit => Err(true),
            _ => Err(false),
        }
    }
}

fn update_button_background<W: Widget>(
    widget: &mut Background<W, BackgroundStyle<BinaryColor>>,
    state: WidgetState,
) {
    match state.state() {
        Button::STATE_HOVERED => widget.background_color(BinaryColor::Off),
        Button::STATE_PRESSED => widget.background_color(BinaryColor::On),
        _ => widget.background_color(BinaryColor::Off),
    }
}

fn update_button_border<W: Widget>(
    widget: &mut Border<W, BorderStyle<BinaryColor>>,
    state: WidgetState,
) {
    match state.state() {
        Button::STATE_HOVERED => widget.border_color(BinaryColor::On),
        Button::STATE_PRESSED => widget.border_color(BinaryColor::Off),
        _ => widget.border_color(BinaryColor::Off),
    }
}

// While this return type is ugly as, it can be generated by the compiler
// (`-> _` gives the type as a compile error ❤)
fn number_button<W: Widget>(
    inner: W,
) -> WidgetWrapper<
    Button<
        WidgetWrapper<
            Background<
                WidgetWrapper<
                    Border<
                        FillParent<W, HorizontalAndVertical, Center, Center>,
                        BorderStyle<BinaryColor>,
                    >,
                >,
                BackgroundStyle<BinaryColor>,
            >,
        >,
    >,
> {
    Button::new(
        Background::new(
            Border::new(
                FillParent::both(inner)
                    .align_horizontal(Center)
                    .align_vertical(Center),
            )
            .border_color(BinaryColor::Off)
            .on_state_changed(update_button_border),
        )
        .background_color(BinaryColor::Off)
        .on_state_changed(update_button_background),
    )
}

fn update_op_button_background<W: Widget>(
    widget: &mut Background<W, BackgroundStyle<BinaryColor>>,
    state: WidgetState,
) {
    match state.state() {
        Button::STATE_HOVERED => widget.background_color(BinaryColor::Off),
        Button::STATE_PRESSED => widget.background_color(BinaryColor::On),
        _ => widget.background_color(BinaryColor::On),
    }
}

fn update_op_label<S, D, F>(
    widget: &mut Label<S, EgCanvas<BinaryColor, D>, LabelStyle<MonoTextStyle<BinaryColor, F>>>,
    state: WidgetState,
) where
    S: AsRef<str>,
    D: DrawTarget<Color = BinaryColor>,
    F: MonoFont,
{
    match state.state() {
        Button::STATE_HOVERED => widget.label_properties.text_color(BinaryColor::On),
        Button::STATE_PRESSED => widget.label_properties.text_color(BinaryColor::Off),
        _ => widget.label_properties.text_color(BinaryColor::Off),
    }
}

// While this return type is ugly as, it can be generated by the compiler
// (`-> _` gives the type as a compile error ❤)
fn op_button<D: DrawTarget<Color = BinaryColor>>(
    label: &'static str,
) -> WidgetWrapper<
    Button<
        WidgetWrapper<
            Spacing<
                WidgetWrapper<
                    Background<
                        WidgetWrapper<
                            Border<
                                FillParent<
                                    WidgetWrapper<
                                        Label<
                                            &'static str,
                                            EgCanvas<BinaryColor, D>,
                                            LabelStyle<MonoTextStyle<BinaryColor, Font6x10>>,
                                        >,
                                    >,
                                    HorizontalAndVertical,
                                    Center,
                                    Center,
                                >,
                                BorderStyle<BinaryColor>,
                            >,
                        >,
                        BackgroundStyle<BinaryColor>,
                    >,
                >,
                EgCanvas<BinaryColor, D>,
            >,
        >,
    >,
> {
    Button::new(
        Spacing::new(
            Background::new(
                Border::new(
                    FillParent::both(
                        // here we have to help the compiler a bit
                        Label::<_, EgCanvas<BinaryColor, D>, _>::new(label)
                            .text_color(BinaryColor::Off)
                            .on_state_changed(update_op_label),
                    )
                    .align_horizontal(Center)
                    .align_vertical(Center),
                )
                .border_color(BinaryColor::On),
            )
            .background_color(BinaryColor::On)
            .on_state_changed(update_op_button_background),
        )
        .left(1),
    )
}

#[derive(Copy, Clone)]
pub enum Op {
    Add,
    Subtract,
    Multiply,
    Divide,
}

impl Op {
    fn calc(self, current: i32, previous: i32) -> i32 {
        match self {
            Op::Add => previous.saturating_add(current),
            Op::Subtract => previous.saturating_sub(current),
            Op::Multiply => previous.saturating_mul(current),
            Op::Divide => {
                // I'm too lazy to add error handling.
                let div = if current == 0 { 1 } else { current };
                previous / div
            }
        }
    }

    fn bind(self, n: i32) -> PrevOp {
        match self {
            Op::Add => PrevOp::Add(n),
            Op::Subtract => PrevOp::Subtract(n),
            Op::Multiply => PrevOp::Multiply(n),
            Op::Divide => PrevOp::Divide(n),
        }
    }
}

#[derive(Copy, Clone)]
pub enum PrevOp {
    Add(i32),
    Subtract(i32),
    Multiply(i32),
    Divide(i32),
}

impl PrevOp {
    fn apply(self, n: i32) -> i32 {
        match self {
            PrevOp::Add(prev) => Op::Add.calc(prev, n),
            PrevOp::Subtract(prev) => Op::Subtract.calc(prev, n),
            PrevOp::Multiply(prev) => Op::Multiply.calc(prev, n),
            PrevOp::Divide(prev) => Op::Divide.calc(prev, n),
        }
    }
}

pub struct Calculator {
    pub previous: i32,
    pub current: i32,
    current_op: Option<Op>,
    prev_op: Option<PrevOp>,
    next_digit_clears: bool,
}

impl Calculator {
    pub fn new() -> Self {
        Calculator {
            previous: 0,
            current: 0,
            current_op: None,
            prev_op: None,
            next_digit_clears: false,
        }
    }

    pub fn clear(&mut self) {
        self.previous = 0;
        self.current = 0;
        self.current_op = None;
        self.prev_op = None;
        self.next_digit_clears = false;
    }

    pub fn add_digit(&mut self, d: i32) {
        if self.next_digit_clears {
            self.next_digit_clears = false;
            self.current = 0;
        }
        if let Some(c) = self.current.checked_mul(10).and_then(|c| c.checked_add(d)) {
            self.current = c;
        }
    }

    pub fn delete_digit(&mut self) {
        self.current = self.current / 10;
    }

    pub fn set_op(&mut self, op: Op) {
        if self.current_op.is_some() {
            self.calc();
        }
        self.previous = self.current;
        self.current_op = Some(op);
        self.next_digit_clears = true;
    }

    pub fn update(&mut self) {
        if self.current_op.is_some() {
            self.calc();
        } else if let Some(prev_op) = self.prev_op {
            self.current = prev_op.apply(self.current);
        }
        self.current_op = None;
        self.next_digit_clears = true;
    }

    fn calc(&mut self) {
        match self.current_op {
            Some(op) => {
                self.prev_op = Some(op.bind(self.current));
                let prev = std::mem::replace(&mut self.previous, self.current);
                self.current = op.calc(self.current, prev);
            }
            None => {}
        }
    }
}

fn main() {
    let display = SimulatorDisplay::<BinaryColor>::new(EgSize::new(128, 64));

    let calculator = BoundData::new(Calculator::new(), |_data| {});

    let mut gui = Window::new(
        EgCanvas::new(display),
        Spacing::new(
            Column::new(Cell::new(
                FillParent::horizontal(
                    Label::new(String::<U11>::from("0"))
                        .bind(&calculator)
                        .on_data_changed(|label, calc| {
                            label.text.clear();
                            write!(label.text, "{}", calc.current).unwrap();
                        }),
                )
                .align_horizontal(Right),
            ))
            .add(
                Cell::new(
                    Row::new(
                        Cell::new(
                            op_button("C")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.clear()),
                        )
                        .weight(2),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("<"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.delete_digit()),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            op_button("/")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.set_op(Op::Divide)),
                        )
                        .weight(1),
                    ),
                )
                .weight(1),
            )
            .add(
                Cell::new(
                    Row::new(
                        Cell::new(
                            number_button(Label::new("7"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(7)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("8"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(8)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("9"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(9)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            op_button("x")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.set_op(Op::Multiply)),
                        )
                        .weight(1),
                    ),
                )
                .weight(1),
            )
            .add(
                Cell::new(
                    Row::new(
                        Cell::new(
                            number_button(Label::new("4"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(4)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("5"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(5)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("6"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(6)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            op_button("-")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.set_op(Op::Subtract)),
                        )
                        .weight(1),
                    ),
                )
                .weight(1),
            )
            .add(
                Cell::new(
                    Row::new(
                        Cell::new(
                            number_button(Label::new("1"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(1)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("2"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(2)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            number_button(Label::new("3"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(3)),
                        )
                        .weight(1),
                    )
                    .add(
                        Cell::new(
                            op_button("+")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.set_op(Op::Add)),
                        )
                        .weight(1),
                    ),
                )
                .weight(1),
            )
            .add(
                Cell::new(
                    Row::new(
                        Cell::new(
                            number_button(Label::new("0"))
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.add_digit(0)),
                        )
                        .weight(3),
                    )
                    .add(
                        Cell::new(
                            op_button("=")
                                .bind(&calculator)
                                .on_clicked(|calculator| calculator.update()),
                        )
                        .weight(1),
                    ),
                )
                .weight(1),
            ),
        )
        .all(2),
    );

    let output_settings = OutputSettingsBuilder::new()
        .theme(BinaryColorTheme::OledBlue)
        .build();
    let mut window = SimWindow::new("GUI demonstration", &output_settings);

    loop {
        gui.canvas.target.clear(BinaryColor::Off).unwrap();

        gui.update();
        gui.measure();
        gui.arrange();
        gui.draw().unwrap();

        // Update the window.
        window.update(&gui.canvas.target);

        // Handle key and mouse events.
        for event in window.events() {
            match convert_input(event) {
                Ok(input) => {
                    gui.input_event(input);
                }
                Err(true) => return,
                _ => {}
            }
        }

        // Wait for a little while.
        thread::sleep(Duration::from_millis(10));
    }
}

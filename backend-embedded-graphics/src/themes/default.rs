use embedded_graphics::{
    draw_target::DrawTarget,
    mono_font::{ascii::Font6x10, MonoTextStyle},
    pixelcolor::BinaryColor,
};
use embedded_gui::widgets::{
    button::Button,
    container::Container,
    label::Label,
    primitives::{
        background::Background,
        border::Border,
        fill::{Center, FillParent, HorizontalAndVertical},
    },
};

use crate::{
    themes::Theme,
    widgets::{
        label::{LabelConstructor, LabelStyle, LabelStyling},
        primitives::{background::BackgroundStyle, border::BorderStyle},
    },
};

pub trait DefaultTheme: Theme {
    const PRIMARY_BUTTON_LABEL_COLOR: Self;
    const PRIMARY_BUTTON_BORDER_COLOR: Self;
    const PRIMARY_BUTTON_BACKGROUND_COLOR: Self;

    const PRIMARY_BUTTON_LABEL_COLOR_HOVERED: Self;
    const PRIMARY_BUTTON_BORDER_COLOR_HOVERED: Self;
    const PRIMARY_BUTTON_BACKGROUND_COLOR_HOVERED: Self;

    const PRIMARY_BUTTON_LABEL_COLOR_PRESSED: Self;
    const PRIMARY_BUTTON_BORDER_COLOR_PRESSED: Self;
    const PRIMARY_BUTTON_BACKGROUND_COLOR_PRESSED: Self;

    const SECONDARY_BUTTON_LABEL_COLOR: Self;
    const SECONDARY_BUTTON_BORDER_COLOR: Self;
    const SECONDARY_BUTTON_BACKGROUND_COLOR: Self;

    const SECONDARY_BUTTON_LABEL_COLOR_HOVERED: Self;
    const SECONDARY_BUTTON_BORDER_COLOR_HOVERED: Self;
    const SECONDARY_BUTTON_BACKGROUND_COLOR_HOVERED: Self;

    const SECONDARY_BUTTON_LABEL_COLOR_PRESSED: Self;
    const SECONDARY_BUTTON_BORDER_COLOR_PRESSED: Self;
    const SECONDARY_BUTTON_BACKGROUND_COLOR_PRESSED: Self;
}

impl Theme for BinaryColor {
    const TEXT_COLOR: BinaryColor = BinaryColor::On;
    const BORDER_COLOR: BinaryColor = BinaryColor::On;
    const BACKGROUND_COLOR: BinaryColor = BinaryColor::Off;
}

// TODO Button styles should be a little better structured
impl DefaultTheme for BinaryColor {
    const PRIMARY_BUTTON_LABEL_COLOR: BinaryColor = BinaryColor::Off;
    const PRIMARY_BUTTON_BORDER_COLOR: BinaryColor = BinaryColor::On;
    const PRIMARY_BUTTON_BACKGROUND_COLOR: BinaryColor = BinaryColor::On;

    const PRIMARY_BUTTON_LABEL_COLOR_HOVERED: BinaryColor = BinaryColor::On;
    const PRIMARY_BUTTON_BORDER_COLOR_HOVERED: BinaryColor = BinaryColor::On;
    const PRIMARY_BUTTON_BACKGROUND_COLOR_HOVERED: BinaryColor = BinaryColor::Off;

    const PRIMARY_BUTTON_LABEL_COLOR_PRESSED: BinaryColor = BinaryColor::Off;
    const PRIMARY_BUTTON_BORDER_COLOR_PRESSED: BinaryColor = BinaryColor::On;
    const PRIMARY_BUTTON_BACKGROUND_COLOR_PRESSED: BinaryColor = BinaryColor::On;

    const SECONDARY_BUTTON_LABEL_COLOR: BinaryColor = BinaryColor::On;
    const SECONDARY_BUTTON_BORDER_COLOR: BinaryColor = BinaryColor::Off;
    const SECONDARY_BUTTON_BACKGROUND_COLOR: BinaryColor = BinaryColor::Off;

    const SECONDARY_BUTTON_LABEL_COLOR_HOVERED: BinaryColor = BinaryColor::On;
    const SECONDARY_BUTTON_BORDER_COLOR_HOVERED: BinaryColor = BinaryColor::On;
    const SECONDARY_BUTTON_BACKGROUND_COLOR_HOVERED: BinaryColor = BinaryColor::Off;

    const SECONDARY_BUTTON_LABEL_COLOR_PRESSED: BinaryColor = BinaryColor::On;
    const SECONDARY_BUTTON_BORDER_COLOR_PRESSED: BinaryColor = BinaryColor::On;
    const SECONDARY_BUTTON_BACKGROUND_COLOR_PRESSED: BinaryColor = BinaryColor::Off;
}

// While this return type is ugly as, it can be generated by the compiler
// (`-> _` gives the type as a compile error ‚ù§)
// TODO: these should wrap a generic button constructor that receives a button style object.
pub fn primary_button<D>(
    label: &'static str,
) -> Container<
    Button<
        Container<
            Background<
                Container<
                    Border<
                        FillParent<
                            Container<
                                Label<
                                    &'static str,
                                    LabelStyle<D, MonoTextStyle<D::Color, Font6x10>>,
                                >,
                            >,
                            HorizontalAndVertical,
                            Center,
                            Center,
                        >,
                        BorderStyle<D::Color>,
                    >,
                >,
                BackgroundStyle<D::Color>,
            >,
        >,
    >,
>
where
    D: DrawTarget,
    D::Color: DefaultTheme,
    BorderStyle<<D as DrawTarget>::Color>: Default,
    BackgroundStyle<<D as DrawTarget>::Color>: Default,
{
    Button::new(
        Background::new(
            Border::new(
                FillParent::both(
                    Label::new(label)
                        .text_color(<D::Color as DefaultTheme>::PRIMARY_BUTTON_LABEL_COLOR)
                        .on_state_changed(|label, state| {
                            label.label_properties.text_color(match state.state() {
                                Button::STATE_HOVERED => {
                                    <D::Color as DefaultTheme>::PRIMARY_BUTTON_LABEL_COLOR_HOVERED
                                }

                                Button::STATE_PRESSED => {
                                    <D::Color as DefaultTheme>::PRIMARY_BUTTON_LABEL_COLOR_PRESSED
                                }

                                _ => <D::Color as DefaultTheme>::PRIMARY_BUTTON_LABEL_COLOR,
                            })
                        }),
                )
                .align_horizontal(Center)
                .align_vertical(Center),
            )
            .border_color(<D::Color as DefaultTheme>::PRIMARY_BUTTON_BORDER_COLOR)
            .on_state_changed(|button, state| {
                button.border_color(match state.state() {
                    Button::STATE_HOVERED => {
                        <D::Color as DefaultTheme>::PRIMARY_BUTTON_BORDER_COLOR_HOVERED
                    }

                    Button::STATE_PRESSED => {
                        <D::Color as DefaultTheme>::PRIMARY_BUTTON_BORDER_COLOR_PRESSED
                    }

                    _ => <D::Color as DefaultTheme>::PRIMARY_BUTTON_BORDER_COLOR,
                })
            }),
        )
        .background_color(<D::Color as DefaultTheme>::PRIMARY_BUTTON_BACKGROUND_COLOR)
        .on_state_changed(|button, state| {
            button.background_color(match state.state() {
                Button::STATE_HOVERED => {
                    <D::Color as DefaultTheme>::PRIMARY_BUTTON_BACKGROUND_COLOR_HOVERED
                }

                Button::STATE_PRESSED => {
                    <D::Color as DefaultTheme>::PRIMARY_BUTTON_BACKGROUND_COLOR_PRESSED
                }

                _ => <D::Color as DefaultTheme>::PRIMARY_BUTTON_BACKGROUND_COLOR,
            })
        }),
    )
}

pub fn secondary_button<D>(
    label: &'static str,
) -> Container<
    Button<
        Container<
            Background<
                Container<
                    Border<
                        FillParent<
                            Container<
                                Label<
                                    &'static str,
                                    LabelStyle<D, MonoTextStyle<D::Color, Font6x10>>,
                                >,
                            >,
                            HorizontalAndVertical,
                            Center,
                            Center,
                        >,
                        BorderStyle<D::Color>,
                    >,
                >,
                BackgroundStyle<D::Color>,
            >,
        >,
    >,
>
where
    D: DrawTarget,
    D::Color: DefaultTheme,
    BorderStyle<<D as DrawTarget>::Color>: Default,
    BackgroundStyle<<D as DrawTarget>::Color>: Default,
{
    Button::new(
        Background::new(
            Border::new(
                FillParent::both(
                    Label::new(label)
                        .text_color(<D::Color as DefaultTheme>::SECONDARY_BUTTON_LABEL_COLOR)
                        .on_state_changed(|label, state| {
                            label.label_properties.text_color(match state.state() {
                                Button::STATE_HOVERED => {
                                    <D::Color as DefaultTheme>::SECONDARY_BUTTON_LABEL_COLOR_HOVERED
                                }

                                Button::STATE_PRESSED => {
                                    <D::Color as DefaultTheme>::SECONDARY_BUTTON_LABEL_COLOR_PRESSED
                                }

                                _ => <D::Color as DefaultTheme>::SECONDARY_BUTTON_LABEL_COLOR,
                            })
                        }),
                )
                .align_horizontal(Center)
                .align_vertical(Center),
            )
            .border_color(<D::Color as DefaultTheme>::SECONDARY_BUTTON_BORDER_COLOR)
            .on_state_changed(|button, state| {
                button.border_color(match state.state() {
                    Button::STATE_HOVERED => {
                        <D::Color as DefaultTheme>::SECONDARY_BUTTON_BORDER_COLOR_HOVERED
                    }

                    Button::STATE_PRESSED => {
                        <D::Color as DefaultTheme>::SECONDARY_BUTTON_BORDER_COLOR_PRESSED
                    }

                    _ => <D::Color as DefaultTheme>::SECONDARY_BUTTON_BORDER_COLOR,
                })
            }),
        )
        .background_color(<D::Color as DefaultTheme>::SECONDARY_BUTTON_BACKGROUND_COLOR)
        .on_state_changed(|button, state| {
            button.background_color(match state.state() {
                Button::STATE_HOVERED => {
                    <D::Color as DefaultTheme>::SECONDARY_BUTTON_BACKGROUND_COLOR_HOVERED
                }

                Button::STATE_PRESSED => {
                    <D::Color as DefaultTheme>::SECONDARY_BUTTON_BACKGROUND_COLOR_PRESSED
                }

                _ => <D::Color as DefaultTheme>::SECONDARY_BUTTON_BACKGROUND_COLOR,
            })
        }),
    )
}
